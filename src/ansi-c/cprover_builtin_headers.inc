"// clang-format off\n"
"void __CPROVER_assume(__CPROVER_bool assumption);\n"
"void __VERIFIER_assume(__CPROVER_bool assumption);\n"
"void __CPROVER_assert(__CPROVER_bool assertion, const char *description);\n"
"void __CPROVER_precondition(__CPROVER_bool precondition, const char *description);\n"
"void __CPROVER_postcondition(__CPROVER_bool assertion, const char *description);\n"
"void __CPROVER_havoc_object(void *);\n"
"void __CPROVER_havoc_slice(void *, __CPROVER_size_t);\n"
"__CPROVER_bool __CPROVER_equal();\n"
"__CPROVER_bool __CPROVER_same_object(const void *, const void *);\n"
"__CPROVER_bool __CPROVER_is_invalid_pointer(const void *);\n"
"_Bool __CPROVER_is_zero_string(const void *);\n"
"__CPROVER_size_t __CPROVER_zero_string_length(const void *);\n"
"__CPROVER_size_t __CPROVER_buffer_size(const void *);\n"
"__CPROVER_bool __CPROVER_r_ok();\n"
"__CPROVER_bool __CPROVER_w_ok();\n"
"__CPROVER_bool __CPROVER_rw_ok();\n"
"\n"
"// experimental features for CHC encodings -- do not use\n"
"__CPROVER_bool __CPROVER_is_list(); // a singly-linked null-terminated dynamically-allocated list\n"
"__CPROVER_bool __CPROVER_is_dll();\n"
"__CPROVER_bool __CPROVER_is_cyclic_dll();\n"
"__CPROVER_bool __CPROVER_is_sentinel_dll();\n"
"__CPROVER_bool __CPROVER_is_cstring(const char *);\n"
"__CPROVER_size_t __CPROVER_cstrlen(const char *);\n"
"__CPROVER_bool __CPROVER_separate(const void *, const void *, ...);\n"
"\n"
"// bitvector analysis\n"
"__CPROVER_bool __CPROVER_get_flag(const void *, const char *);\n"
"void __CPROVER_set_must(const void *, const char *);\n"
"void __CPROVER_clear_must(const void *, const char *);\n"
"void __CPROVER_set_may(const void *, const char *);\n"
"void __CPROVER_clear_may(const void *, const char *);\n"
"void __CPROVER_cleanup(const void *, const void *);\n"
"__CPROVER_bool __CPROVER_get_must(const void *, const char *);\n"
"__CPROVER_bool __CPROVER_get_may(const void *, const char *);\n"
"\n"
"void __CPROVER_printf(const char *format, ...);\n"
"void __CPROVER_input(const char *id, ...);\n"
"void __CPROVER_output(const char *id, ...);\n"
"void __CPROVER_cover(__CPROVER_bool condition);\n"
"\n"
"// concurrency-related\n"
"void __CPROVER_atomic_begin();\n"
"void __CPROVER_atomic_end();\n"
"void __CPROVER_fence(const char *kind, ...);\n"
"\n"
"// contract-related functions\n"
"__CPROVER_bool __CPROVER_is_freeable(const void *mem);\n"
"__CPROVER_bool __CPROVER_was_freed(const void *mem);\n"
"__CPROVER_bool __CPROVER_is_fresh(const void *mem, __CPROVER_size_t size);\n"
"void __CPROVER_old(const void *);\n"
"void __CPROVER_loop_entry(const void *);\n"
"\n"
"// pointers\n"
"__CPROVER_bool __CPROVER_LIVE_OBJECT(const void *);\n"
"__CPROVER_bool __CPROVER_WRITEABLE_OBJECT(const void *);\n"
"__CPROVER_size_t __CPROVER_POINTER_OBJECT(const void *);\n"
"__CPROVER_ssize_t __CPROVER_POINTER_OFFSET(const void *);\n"
"__CPROVER_size_t __CPROVER_OBJECT_SIZE(const void *);\n"
"__CPROVER_bool __CPROVER_DYNAMIC_OBJECT(const void *);\n"
"__CPROVER_bool __CPROVER_pointer_in_range(const void *, const void *, const void *);\n"
"void __CPROVER_allocated_memory(__CPROVER_size_t address, __CPROVER_size_t extent);\n"
"\n"
"// float stuff\n"
"int __CPROVER_fpclassify(int, int, int, int, int, ...);\n"
"__CPROVER_bool __CPROVER_isnanf(float f);\n"
"__CPROVER_bool __CPROVER_isnand(double f);\n"
"__CPROVER_bool __CPROVER_isnanld(long double f);\n"
"__CPROVER_bool __CPROVER_isfinitef(float f);\n"
"__CPROVER_bool __CPROVER_isfinited(double f);\n"
"__CPROVER_bool __CPROVER_isfiniteld(long double f);\n"
"__CPROVER_bool __CPROVER_isinff(float f);\n"
"__CPROVER_bool __CPROVER_isinfd(double f);\n"
"__CPROVER_bool __CPROVER_isinfld(long double f);\n"
"__CPROVER_bool __CPROVER_isnormalf(float f);\n"
"__CPROVER_bool __CPROVER_isnormald(double f);\n"
"__CPROVER_bool __CPROVER_isnormalld(long double f);\n"
"__CPROVER_bool __CPROVER_signf(float f);\n"
"__CPROVER_bool __CPROVER_signd(double f);\n"
"__CPROVER_bool __CPROVER_signld(long double f);\n"
"double __CPROVER_inf(void);\n"
"float __CPROVER_inff(void);\n"
"long double __CPROVER_infl(void);\n"
"int __CPROVER_isgreaterf(float f, float g);\n"
"int __CPROVER_isgreaterd(double f, double g);\n"
"int __CPROVER_isgreaterequalf(float f, float g);\n"
"int __CPROVER_isgreaterequald(double f, double g);\n"
"int __CPROVER_islessf(float f, float g);\n"
"int __CPROVER_islessd(double f, double g);\n"
"int __CPROVER_islessequalf(float f, float g);\n"
"int __CPROVER_islessequald(double f, double g);\n"
"int __CPROVER_islessgreaterf(float f, float g);\n"
"int __CPROVER_islessgreaterd(double f, double g);\n"
"int __CPROVER_isunorderedf(float f, float g);\n"
"int __CPROVER_isunorderedd(double f, double g);\n"
"\n"
"// absolute value\n"
"int __CPROVER_abs(int x);\n"
"long int __CPROVER_labs(long int x);\n"
"long long int __CPROVER_llabs(long long int x);\n"
"double __CPROVER_fabs(double x);\n"
"long double __CPROVER_fabsl(long double x);\n"
"float __CPROVER_fabsf(float x);\n"
"\n"
"// modulo and remainder\n"
"double __CPROVER_fmod(double, double);\n"
"float __CPROVER_fmodf(float, float);\n"
"long double __CPROVER_fmodl(long double, long double);\n"
"double __CPROVER_remainder(double, double);\n"
"float __CPROVER_remainderf(float, float);\n"
"long double __CPROVER_remainderl(long double, long double);\n"
"\n"
"// arrays\n"
"__CPROVER_bool __CPROVER_array_equal(const void *array1, const void *array2);\n"
"// overwrite all of *dest (possibly using nondet values), even\n"
"// if *src is smaller\n"
"void __CPROVER_array_copy(const void *dest, const void *src);\n"
"// replace at most size-of-*src bytes in *dest\n"
"void __CPROVER_array_replace(const void *dest, const void *src);\n"
"void __CPROVER_array_set(const void *dest, ...);\n"
"\n"
"// k-induction\n"
"void __CPROVER_k_induction_hint(unsigned min, unsigned max, \n"
"  unsigned step, unsigned loop_free);\n"
"\n"
"// format string-related\n"
"int __CPROVER_scanf(const char *, ...);\n"
"\n"
"// detect overflow\n"
"__CPROVER_bool __CPROVER_overflow_minus();\n"
"__CPROVER_bool __CPROVER_overflow_mult();\n"
"__CPROVER_bool __CPROVER_overflow_plus();\n"
"__CPROVER_bool __CPROVER_overflow_shl();\n"
"__CPROVER_bool __CPROVER_overflow_unary_minus();\n"
"\n"
"// enumerations\n"
"__CPROVER_bool __CPROVER_enum_is_in_range();\n"
"\n"
"// contracts\n"
"void __CPROVER_assignable(void *ptr, __CPROVER_size_t size,\n"
"  __CPROVER_bool is_ptr_to_ptr);\n"
"void __CPROVER_object_whole(void *ptr);\n"
"void __CPROVER_object_from(void *ptr);\n"
"void __CPROVER_object_upto(void *ptr, __CPROVER_size_t size);\n"
"void __CPROVER_freeable(void *ptr);\n"
"// clang-format on\n"
