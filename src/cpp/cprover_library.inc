{
{ "__new",
  "#line 1 \"<builtin-library-__new>\"\n"
  "\n"
  "__CPROVER_bool __VERIFIER_nondet___CPROVER_bool();\n"
  "\n"
  "inline void *__new(__typeof__(sizeof(int)) malloc_size)\n"
  "{\n"
  "  // The constructor call is done by the front-end.\n"
  "  // This just does memory allocation.\n"
  "  __CPROVER_HIDE:;\n"
  "  void *res;\n"
  "  res = __CPROVER_allocate(malloc_size, 0);\n"
  "\n"
  "  // ensure it's not recorded as deallocated\n"
  "  __CPROVER_deallocated=(res==__CPROVER_deallocated)?0:__CPROVER_deallocated;\n"
  "\n"
  "  // non-deterministically record the object for delete/delete[] checking\n"
  "  __CPROVER_bool record_malloc=__VERIFIER_nondet___CPROVER_bool();\n"
  "  __CPROVER_new_object = record_malloc ? res : __CPROVER_new_object;\n"
  "  __CPROVER_malloc_is_new_array=record_malloc?0:__CPROVER_malloc_is_new_array;\n"
  "\n"
  "  // detect memory leaks\n"
  "  __CPROVER_bool record_may_leak=__VERIFIER_nondet___CPROVER_bool();\n"
  "  __CPROVER_memory_leak=record_may_leak?res:__CPROVER_memory_leak;\n"
  "\n"
  "  return res;\n"
  "}\n"
  "\n"
},
{ "__new_array",
  "#line 1 \"<builtin-library-__new_array>\"\n"
  "\n"
  "__CPROVER_bool __VERIFIER_nondet___CPROVER_bool();\n"
  "\n"
  "inline void *__new_array(__CPROVER_size_t count, __CPROVER_size_t size)\n"
  "{\n"
  "  // The constructor call is done by the front-end.\n"
  "  // This just does memory allocation.\n"
  "  __CPROVER_HIDE:;\n"
  "  void *res;\n"
  "  res = __CPROVER_allocate(size*count, 0);\n"
  "\n"
  "  // ensure it's not recorded as deallocated\n"
  "  __CPROVER_deallocated=(res==__CPROVER_deallocated)?0:__CPROVER_deallocated;\n"
  "\n"
  "  // non-deterministically record the object for delete/delete[] checking\n"
  "  __CPROVER_bool record_malloc=__VERIFIER_nondet___CPROVER_bool();\n"
  "  __CPROVER_new_object = record_malloc ? res : __CPROVER_new_object;\n"
  "  __CPROVER_malloc_is_new_array=record_malloc?1:__CPROVER_malloc_is_new_array;\n"
  "\n"
  "  // detect memory leaks\n"
  "  __CPROVER_bool record_may_leak=__VERIFIER_nondet___CPROVER_bool();\n"
  "  __CPROVER_memory_leak=record_may_leak?res:__CPROVER_memory_leak;\n"
  "\n"
  "  return res;\n"
  "}\n"
  "\n"
},
{ "__placement_new",
  "#line 1 \"<builtin-library-__placement_new>\"\n"
  "\n"
  "inline void *__placement_new(__typeof__(sizeof(int)) malloc_size, void *p)\n"
  "{\n"
  "  // The constructor call is done by the front-end.\n"
  "  // The allocation is done by the user. So this does nothing.\n"
  "  __CPROVER_HIDE:;\n"
  "  (void)malloc_size;\n"
  "  return p;\n"
  "}\n"
  "\n"
},
{ "__delete",
  "#line 1 \"<builtin-library-__delete>\"\n"
  "\n"
  "__CPROVER_bool __VERIFIER_nondet___CPROVER_bool();\n"
  "\n"
  "inline void __delete(void *ptr)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  // is it dynamic?\n"
  "  __CPROVER_precondition(ptr==0 || __CPROVER_DYNAMIC_OBJECT(ptr),\n"
  "                         \"delete argument must be dynamic object\");\n"
  "  __CPROVER_precondition(__CPROVER_POINTER_OFFSET(ptr)==0,\n"
  "                         \"delete argument must have offset zero\");\n"
  "\n"
  "  // catch double delete\n"
  "  __CPROVER_precondition(ptr==0 || __CPROVER_deallocated!=ptr, \"double delete\");\n"
  "\n"
  "  // catch people who call delete for objects allocated with new[]\n"
  "  __CPROVER_precondition(\n"
  "    ptr == 0 || __CPROVER_new_object != ptr || !__CPROVER_malloc_is_new_array,\n"
  "    \"delete of array object\");\n"
  "\n"
  "  // If ptr is NULL, no operation is performed.\n"
  "  // This is a requirement by the standard, not generosity!\n"
  "  if(ptr!=0)\n"
  "  {\n"
  "    __CPROVER_deallocate(ptr);\n"
  "\n"
  "    // detect memory leaks\n"
  "    if(__CPROVER_memory_leak==ptr)\n"
  "      __CPROVER_memory_leak=0;\n"
  "  }\n"
  "}\n"
  "\n"
},
{ "__delete_array",
  "#line 1 \"<builtin-library-__delete_array>\"\n"
  "\n"
  "__CPROVER_bool __VERIFIER_nondet___CPROVER_bool();\n"
  "\n"
  "inline void __delete_array(void *ptr)\n"
  "{\n"
  "  __CPROVER_HIDE:;\n"
  "  // If ptr is NULL, no operation is performed.\n"
  "  // This is a requirement by the standard, not generosity!\n"
  "\n"
  "  // is it dynamic?\n"
  "  __CPROVER_precondition(ptr==0 || __CPROVER_DYNAMIC_OBJECT(ptr),\n"
  "                         \"delete argument must be dynamic object\");\n"
  "  __CPROVER_precondition(ptr==0 || __CPROVER_POINTER_OFFSET(ptr)==0,\n"
  "                         \"delete argument must have offset zero\");\n"
  "\n"
  "  // catch double delete\n"
  "  __CPROVER_precondition(ptr==0 || __CPROVER_deallocated!=ptr,\n"
  "                         \"double delete\");\n"
  "\n"
  "  // catch people who call delete[] for objects allocated with new\n"
  "  __CPROVER_precondition(\n"
  "    ptr == 0 || __CPROVER_new_object != ptr || __CPROVER_malloc_is_new_array,\n"
  "    \"delete[] of non-array object\");\n"
  "\n"
  "  if(ptr!=0)\n"
  "  {\n"
  "    __CPROVER_deallocate(ptr);\n"
  "\n"
  "    // detect memory leaks\n"
  "    if(__CPROVER_memory_leak==ptr) __CPROVER_memory_leak=0;\n"
  "  }\n"
  "}\n"
},
{ 0, 0 }
}