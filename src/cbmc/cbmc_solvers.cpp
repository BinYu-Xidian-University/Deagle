/*******************************************************************\

Module: Solvers for VCs Generated by Symbolic Execution of ANSI-C

Author: Daniel Kroening, kroening@kroening.com

\*******************************************************************/

#include <memory>
#include <iostream>
#include <map>
#include <algorithm>

#include <solvers/sat/satcheck.h>
#include <solvers/sat/satcheck_minisat2.h>

#include <solvers/refinement/bv_refinement.h>
#include <solvers/smt1/smt1_dec.h>
#include <solvers/smt2/smt2_dec.h>
#include <solvers/cvc/cvc_dec.h>
#include <util/time_stopping.h>

#include <solvers/prop/aig_prop.h>

#include "bmc.h"
#include "bv_cbmc.h"
#include "counterexample_beautification.h"
#include "version.h"
#include "eog.h"
#include <iostream>
#include <iomanip>
#include <vector>
//// __FHY_ADD_BEGIN__
#include <util/simplify_expr.h>
//// __FHY_ADD_END__

const double time_limit  = 50;   // the time limit for one run
const int max_two_rf_num = 1000000;
/*******************************************************************\

Function: bmct::get_smt1_solver_type

  Inputs: None

 Outputs: An smt1_dect::solvert giving the solver to use.

 Purpose: Uses the options to pick an SMT 1.2 solver

\*******************************************************************/

smt1_dect::solvert bmct::get_smt1_solver_type() const
{
    assert(options.get_bool_option("smt1"));

    smt1_dect::solvert s = smt1_dect::GENERIC;

    if(options.get_bool_option("boolector"))
        s = smt1_dect::BOOLECTOR;
    else if(options.get_bool_option("mathsat"))
        s = smt1_dect::MATHSAT;
    else if(options.get_bool_option("cv3"))
        s = smt1_dect::CVC3;
    else if(options.get_bool_option("cv4"))
        s = smt1_dect::CVC4;
    else if(options.get_bool_option("opensmt"))
        s = smt1_dect::OPENSMT;
    else if(options.get_bool_option("yices"))
        s = smt1_dect::YICES;
    else if(options.get_bool_option("z3"))
        s = smt1_dect::Z3;
    else if(options.get_bool_option("generic"))
        s = smt1_dect::GENERIC;

    return s;
}

/*******************************************************************\

Function: bmct::get_smt2_solver_type

  Inputs: None

 Outputs: An smt2_dect::solvert giving the solver to use.

 Purpose: Uses the options to pick an SMT 2.0 solver

\*******************************************************************/

smt2_dect::solvert bmct::get_smt2_solver_type() const
{
    assert(options.get_bool_option("smt2"));

    smt2_dect::solvert s = smt2_dect::GENERIC;

    if(options.get_bool_option("boolector"))
        s = smt2_dect::BOOLECTOR;
    else if(options.get_bool_option("mathsat"))
        s = smt2_dect::MATHSAT;
    else if(options.get_bool_option("cv3"))
        s = smt2_dect::CVC3;
    else if(options.get_bool_option("cv4"))
        s = smt2_dect::CVC4;
    else if(options.get_bool_option("opensmt"))
        s = smt2_dect::OPENSMT;
    else if(options.get_bool_option("yices"))
        s = smt2_dect::YICES;
    else if(options.get_bool_option("z3"))
        s = smt2_dect::Z3;
    else if(options.get_bool_option("generic"))
        s = smt2_dect::GENERIC;

    return s;
}

/*******************************************************************\

Function: bmct::solver_factory

  Inputs:

 Outputs:

 Purpose: Decide using "default" decision procedure

\*******************************************************************/

prop_convt *bmct::solver_factory()
{
    //const std::string &filename=options.get_option("outfile");

    if(options.get_bool_option("boolector"))
    {
    }
    else if(options.get_bool_option("mathsat"))
    {
    }
    else if(options.get_bool_option("cvc"))
    {
    }
    else if(options.get_bool_option("dimacs"))
    {
    }
    else if(options.get_bool_option("opensmt"))
    {
    }
    else if(options.get_bool_option("refine"))
    {
    }
    else if(options.get_bool_option("aig"))
    {
    }
    else if(options.get_bool_option("smt1"))
    {
    }
    else if(options.get_bool_option("smt2"))
    {
    }
    else if(options.get_bool_option("yices"))
    {
    }
    else if(options.get_bool_option("z3"))
    {
    }
    else
    {
        // THE DEFAULT

#if 0
        // SAT preprocessor won't work with beautification.
    if(options.get_bool_option("sat-preprocessor") &&
       !options.get_bool_option("beautify"))
    {
      solver=std::auto_ptr<propt>(new satcheckt);
    }
    else
      solver=std::auto_ptr<propt>(new satcheck_minisat_no_simplifiert);

    solver->set_message_handler(get_message_handler());
      
    bv_cbmct bv_cbmc(ns, *solver);
      
    if(options.get_option("arrays-uf")=="never")
      bv_cbmc.unbounded_array=bv_cbmct::U_NONE;
    else if(options.get_option("arrays-uf")=="always")
      bv_cbmc.unbounded_array=bv_cbmct::U_ALL;
#endif
    }

    return 0;
}

/*******************************************************************\

Function: bmct::decide_aig

  Inputs:

 Outputs:

 Purpose: Decide using AIG followed by SAT

\*******************************************************************/

bool bmct::decide_aig()
{
    bool result=true;

    std::auto_ptr<propt> sub_solver;

    if(options.get_bool_option("sat-preprocessor"))
        sub_solver=std::auto_ptr<propt>(new satcheckt);
    else
        sub_solver=std::auto_ptr<propt>(new satcheck_minisat_no_simplifiert);

    aig_prop_solvert solver(*sub_solver);

    solver.set_message_handler(get_message_handler());

    bv_cbmct bv_cbmc(ns, solver);

    if(options.get_option("arrays-uf")=="never")
        bv_cbmc.unbounded_array=bv_cbmct::U_NONE;
    else if(options.get_option("arrays-uf")=="always")
        bv_cbmc.unbounded_array=bv_cbmct::U_ALL;

    switch(run_decision_procedure(bv_cbmc))
    {
        case decision_proceduret::D_UNSATISFIABLE:
            result=false;
            report_success();
            break;

        case decision_proceduret::D_SATISFIABLE:
            error_trace(bv_cbmc);
            report_failure();
            break;

        default:
            error() << "decision procedure failed" << eom;
    }

    return result;
}

/*******************************************************************\

Function: bmct::bv_refinement

  Inputs:

 Outputs:

 Purpose: Decide using refinement decision procedure

\*******************************************************************/

bool bmct::decide_bv_refinement()
{
    std::auto_ptr<propt> solver;

    // We offer the option to disable the SAT preprocessor
    if(options.get_bool_option("sat-preprocessor"))
        solver=std::auto_ptr<propt>(new satcheckt);
    else
        solver=std::auto_ptr<propt>(new satcheck_minisat_no_simplifiert);

    solver->set_message_handler(get_message_handler());

    bv_refinementt bv_refinement(ns, *solver);

    // we allow setting some parameters
    if(options.get_option("max-node-refinement")!="")
        bv_refinement.max_node_refinement=
                options.get_unsigned_int_option("max-node-refinement");

    return decide(bv_refinement);
}

/*******************************************************************\

Function: bmct::decide_smt1

  Inputs:

 Outputs:

 Purpose:

\*******************************************************************/

bool bmct::decide_smt1()
{
    smt1_dect::solvert solver=get_smt1_solver_type();
    const std::string &filename=options.get_option("outfile");

    if(filename=="")
    {
        smt1_dect smt1_dec(
                ns,
                "cbmc",
                "Generated by CBMC " CBMC_VERSION,
                "QF_AUFBV",
                solver);

        return decide(smt1_dec);
    }
    else if(filename=="-")
        smt1_convert(solver, std::cout);
    else
    {
        std::ofstream out(filename.c_str());
        if(!out)
        {
            std::cerr << "failed to open " << filename << std::endl;
            return false;
        }

        smt1_convert(solver, out);
    }

    return false;
}

/*******************************************************************\

Function: bmct::smt1_convert

  Inputs:

 Outputs:

 Purpose:

\*******************************************************************/

void bmct::smt1_convert(smt1_dect::solvert solver, std::ostream &out)
{
    smt1_convt smt1_conv(
            ns,
            "cbmc",
            "Generated by CBMC " CBMC_VERSION,
            "QF_AUFBV",
            solver,
            out);

    smt1_conv.set_message_handler(get_message_handler());

    do_conversion(smt1_conv);

    smt1_conv.dec_solve();
}

/*******************************************************************\

Function: bmct::decide_smt2

  Inputs:

 Outputs:

 Purpose:

\*******************************************************************/

bool bmct::decide_smt2()
{
    smt2_dect::solvert solver=get_smt2_solver_type();
    const std::string &filename=options.get_option("outfile");
    if(filename.empty())
    {
        //// __FHY_ADD_BEGIN__
        smt2_dect smt2_dec(
                ns,
                "cbmc",
                "Generated by CBMC " CBMC_VERSION,
                "QF_AUFBV",
                solver,
                equation.oclt_type_table,
                equation.oclt_node_guard_map);
        //// __FHY_ADD_END__

//        if(options.get_bool_option("fpa"))
//            smt2_dec.use_FPA_theory=true;

        //// __FHY_ADD_BEGIN__
        // we use FPA_theory by default to support floatbv in SVComp
//        if(options.get_option("original_file").find("pthread-complex")!=std::string::npos)
//            smt2_dec.use_datatypes = false;
        smt2_dec.use_FPA_theory=true;
        //// __FHY_ADD_END__

        //// __FHY_ADD_BEGIN__
        // Use EOG to compute the first constraints
        exprt init_cons;

        compute_init_refinement(smt2_dec, init_cons);

        simplify(init_cons, ns);
        equation.constraint(init_cons, "", equation.SSA_steps.begin()->source);
        //// __FHY_ADD_END__

        return decide(smt2_dec);
    }
    else if(filename=="-")
        smt2_convert(solver, std::cout);
    else
    {
        std::ofstream out(filename.c_str());
        if(!out)
        {
            std::cerr << "failed to open " << filename << std::endl;
            return false;
        }

        smt2_convert(solver, out);
    }

    return false;
}

/*******************************************************************\

Function: bmct::smt2_convert

  Inputs:

 Outputs:

 Purpose:

\*******************************************************************/

void bmct::smt2_convert(
        smt2_dect::solvert solver,
        std::ostream &out)
{
    //// __FHY_ADD_BEGIN__
    smt2_convt smt2_conv(
            ns,
            "cbmc",
            "Generated by CBMC " CBMC_VERSION,
            "QF_AUFBV",
            solver,
            out,
            equation.oclt_type_table,
            equation.oclt_node_guard_map);
    //// __FHY_ADD_END__

//    if(options.get_bool_option("fpa"))
//        smt2_conv.use_FPA_theory=true;

    //// __FHY_ADD_BEGIN__
//    if(options.get_option("original_file").find("pthread-complex")!=std::string::npos)
//        smt2_conv.use_datatypes = false;
    smt2_conv.use_FPA_theory=true;
    //// __FHY_ADD_END__

    smt2_conv.set_message_handler(get_message_handler());

    //// __FHY_ADD_BEGIN__
    // Use EOG to compute the first constraints
    exprt init_cons;

    compute_init_refinement(smt2_conv, init_cons);

    simplify(init_cons, ns);
    equation.constraint(init_cons, "", equation.SSA_steps.begin()->source);
    //// __FHY_ADD_END__

    do_conversion(smt2_conv);

    smt2_conv.dec_solve();
}


// ===================================================================
// Functions for EOG-based CEGAR
// ===================================================================
int bmct::decide_default(bool threads_reduced)
{
    // SZH add for workstealqueue

    // SZH add end

    std::cout << "call decide_default with threads_reduced " << threads_reduced << "\n";
    int result=1;

    std::auto_ptr<propt> solver;

    // SAT preprocessor won't work with beautification.
    if(options.get_bool_option("sat-preprocessor") &&
       !options.get_bool_option("beautify"))
    {
        std::cout << "use satcheck\n";
        solver=std::auto_ptr<propt>(new satcheckt);
    }
    else
    {
        std::cout << "use satcheck no simplifier\n";
        solver = std::auto_ptr<propt>(new satcheck_minisat_no_simplifiert);
    }

    solver->set_message_handler(get_message_handler());

    bv_cbmct bv_cbmc(ns, *solver);

    if(options.get_option("arrays-uf")=="never")
    {
        bv_cbmc.unbounded_array = bv_cbmct::U_NONE;
        std::cout << "arrays-uf is never\n";
    }
    else if(options.get_option("arrays-uf")=="always")
    {
        bv_cbmc.unbounded_array = bv_cbmct::U_ALL;
        std::cout << "arrays-uf is always\n";
    }

    // add the initial refinements that can be inferred without any EOG analysis
    exprt init_refinement;

    compute_init_refinement(bv_cbmc, init_refinement);

    bv_cbmc.set_to_true(init_refinement);

    absolute_timet t_start_solving=current_time();
    decision_proceduret::resultt rrt = run_decision_procedure(bv_cbmc);

    int num = 0;
    switch(rrt)
    {
        case decision_proceduret::D_UNSATISFIABLE:
            result=0;
            if (!threads_reduced)
                report_success_witness();
            break;

        case decision_proceduret::D_SATISFIABLE:
            exprt refinement;
            DEOG deog(&equation);
            add_all_nodes(deog);

            //=====================================================
            while(1)
            {
                EOG eog;
                EOG_extraction(bv_cbmc, eog);

                bool true_CE = CE_evaluation_graph(eog, deog);

                if (true_CE)
                {
                    std::vector<symbol_exprt> unsat_core;
                    std::vector<irep_idt> write_order;
                    true_CE = CE_evaluation_constraint(eog, unsat_core, write_order);
                    if (true_CE)
                    {
                        std::cout << "Counterexample evaluation: FEASIBLE\n";

                        for(auto rf: deog.m_rfs)
                        {
                            std::cout << "rf: " << rf->m_src->m_event->identifier << " " << rf->m_dst->m_event->identifier << "\n";
                        }

//				for (int i = 0; i < write_order.size(); i++)
//					std::cout << write_order[i] << "\n";

                        true_CE_generation(bv_cbmc, write_order);
                        result = 1;
                        break;
                    }
                    else
                    {
                        refinement_generation_constraint(unsat_core, refinement);
                    }
                }
                else
                {
                    refinement_generation_graph(deog, refinement);
                }

                deog.clear();

//                std::cout << "Counterexample evaluation: INFEASIBLE\n";
//                std::cout << "\n================= Refine " << num++ << " =================\n";

                // incremental algorithm
//                std::cout << from_expr(equation.ns, "", refinement) << "\n";
                decision_proceduret::resultt rt = incremental_solve(bv_cbmc, refinement);

                if(rt == decision_proceduret::D_UNSATISFIABLE)
                {
                    if (!threads_reduced)
                        report_success_witness();
                    result = 0;
                    break;
                }
                else if (rt != decision_proceduret::D_SATISFIABLE)
                {
                    assert(false);
                    result = 2;
                    break;
                }

                double solving_time = (double)((current_time() - t_start_solving).get_t())/1000;
                if (threads_reduced && solving_time > time_limit)
                {
                    result = 2; // unknow
                    break;
                }
            }
            break;
    }

//	std::ofstream out("cega.result", std::ios::app);
//	out << (result ? "SAT" : "UNSAT") << " " << num << " " << solve_time << " " << evaluation_time << " " << constraint_compute_time << " ";
//	out.close();*/
    return result;
}

void bmct::EOG_extraction(prop_convt &prop_conv, EOG& eog, bool trace_flag)
{
    nodes_extraction(eog, prop_conv, trace_flag);

    program_order_extraction(eog, prop_conv, trace_flag);

    read_from_extraction(eog, prop_conv);
}

bool bmct::CE_evaluation_graph(EOG& eog, DEOG& deog)
{
    deog.optimize = true;
    deog_generation(deog, eog);

    if (deog.no_circle_judge()) {
        deog.optimize = false;
        deog_generation(deog, eog);
        return deog.no_circle_judge();
    }
    return false;
}

int shared_write_order_cmp(const shared_write_order& a, const shared_write_order& b)
{
    return (a.clock < b.clock || (a.clock == b.clock && a.line < b.line));
}

bool bmct::CE_evaluation_constraint(EOG& eog, std::vector<symbol_exprt>& unsat_core, std::vector<irep_idt>& write_order)
{
    std::auto_ptr<propt> solver;
    solver=std::auto_ptr<propt>(new satcheck_minisat_no_simplifiert);
    solver->set_message_handler(get_message_handler());
    bv_cbmct bv_cbmc(ns, *solver);

    bvt assumptions;
    std::map<event_it, EPO> epo_map;
    exprt program_order = true_exprt();
    encode_program_order(eog, program_order, epo_map);
    bv_cbmc.set_to_true(program_order);

    std::map<literalt, symbol_exprt> lit_choice_map;
    encode_read_from(eog, bv_cbmc, assumptions, lit_choice_map, epo_map);
    bv_cbmc.set_assumptions(assumptions);

    decision_proceduret::resultt dec_result = bv_cbmc.dec_solve();

    if (dec_result == decision_proceduret::D_UNSATISFIABLE) {
        for (unsigned i = 0; i < assumptions.size(); i++)
            if(bv_cbmc.is_in_conflict(assumptions[i]))
                unsat_core.push_back(lit_choice_map[assumptions[i]]);
    }
    else if (dec_result == decision_proceduret::D_SATISFIABLE) {
        //===================================================================
        std::vector<shared_write_order> order;
        bool main_func_flag = false;
        for(eventst::const_iterator
                    e_it=equation.SSA_steps.begin();
            e_it!=equation.SSA_steps.end();
            e_it++)
        {
            if(e_it->is_shared_write() && e_it->is_program_var())
            {
                shared_write_order tmp;
                tmp.event = e_it;
                tmp.line = atoi(id2string(e_it->source.pc->source_location.get_line()).c_str());

                int value = atoi(from_expr(ns, "", bv_cbmc.get(memory_model->clock(e_it))).c_str());
                tmp.clock = (main_func_flag ? value : 0);
                order.push_back(tmp);
            }
            if (e_it->is_function_call() && e_it->identifier == "c::main")
                main_func_flag = true;
        }

        sort(order.begin(), order.end(), shared_write_order_cmp);

        for (unsigned i = 0; i < order.size(); i++)
        {
            write_order.push_back(order[i].event->ssa_lhs.get_identifier());
//			std::cout << "CCCCCC " << order[i].event->ssa_lhs.get_identifier() << " " << order[i].line << " " << order[i].clock << "\n";
        }


    }

    return dec_result == decision_proceduret::D_SATISFIABLE;
}

void bmct::refinement_generation_graph(DEOG& deog, exprt& refinement)
{
    deog.compute_all_cycles();

    exprt::operandst constraint_operands;

    std::cout << "num of cycles: " << deog.m_reasons.size() << "\n";
    for (unsigned i = 0; i < deog.m_reasons.size(); i++) {
        std::vector<exprt>& reason = deog.m_reasons[i];

        if (i > 0 && reason.size() > 10)
            continue;

        exprt::operandst reason_operands;
        for (unsigned j = 0; j < reason.size(); j++) {
            reason_operands.push_back(not_exprt(reason[j]));
        }

        exprt reason_exprt = disjunction(reason_operands);

        constraint_operands.push_back(reason_exprt);
    }
    refinement = conjunction(constraint_operands);
}

void bmct::refinement_generation_constraint(std::vector<symbol_exprt>& unsat_core, exprt& refinement)
{
    exprt::operandst operands;
    for (unsigned i = 0; i < unsat_core.size(); i++)
        operands.push_back(not_exprt(unsat_core[i]));
    refinement = disjunction(operands);
}

void bmct::true_CE_generation(bv_cbmct &bv_cbmc, std::vector<irep_idt>& write_order)
{
    if(options.get_bool_option("beautify"))
        counterexample_beautificationt()(
                bv_cbmc, equation, ns);

    error_trace(bv_cbmc);
    report_failure_witness(bv_cbmc, write_order);
}

// -------------------------------------------------------------
// Functions for EOG_extraction
// -------------------------------------------------------------
void bmct::nodes_extraction(EOG& eog, prop_convt &prop_conv, bool trace_flag)
{
    for(eventst::iterator
                e_it=equation.SSA_steps.begin();
        e_it!=equation.SSA_steps.end();
        e_it++)
    {
        if ((e_it->is_shared_read() || e_it->is_shared_write() ||
             e_it->is_spawn() || e_it->is_memory_barrier()) &&
            (!trace_flag || prop_conv.l_get((*e_it).guard_literal)==tvt(true))) {
            eog.m_nodes.push_back(&(*e_it));
        }
    }
}

void bmct::program_order_extraction(EOG& eog, prop_convt &prop_conv, bool trace_flag)
{
    per_thread_mapt per_thread_map;
    std::map<irep_idt, unsigned> thread_map; // <thread_identifier, thread_id> for all threads
    exprt tmpc; tmpc.make_false();

    // build per_thread_map
    for(eventst::const_iterator
                e_it=equation.SSA_steps.begin();
        e_it!=equation.SSA_steps.end();
        e_it++)
    {
        // concurreny-related?
        if(!e_it->is_shared_read() &&
           !e_it->is_shared_write() &&
           !e_it->is_spawn() &&
           !e_it->is_memory_barrier() &&
           !e_it->is_verify_atomic_begin(equation.mutex_flag) &&
           !e_it->is_verify_atomic_end(equation.mutex_flag) &&
           !e_it->is_thread_join()) continue;

        if ((trace_flag && prop_conv.l_get((*e_it).guard_literal)!=tvt(true)) &&
            !e_it->is_thread_join())
            continue;

        if (!equation.thread_malloc && equation.aux_enable && e_it->is_aux_var())
            continue;

        per_thread_map[e_it->source.thread_nr].push_back(e_it);
    }

    thread_spawn(equation, per_thread_map, prop_conv, eog, trace_flag);

    bool join_flag = false;
    std::vector<int> unhandled;
    std::map<int, event_it> join_nodes;
    int thr_n = 0;

    // iterate over threads
    for(per_thread_mapt::const_iterator
                t_it=per_thread_map.begin();
        t_it!=per_thread_map.end();
        t_it++)
    {
        const event_listt &events=t_it->second;
        bool atomic_flag = false;
        bool start_flag = false;
        bool lock_flag = false;
        bool array_assign = false;
        bool struct_assign = false;

        event_it array_event;
        event_it struct_event;

        std::map<irep_idt, event_it> event_value_map;
        unhandled.clear();
        join_flag = false;

        // iterate over relevant events in the thread
        event_it previous=equation.SSA_steps.end();

        for(event_listt::const_iterator
                    e_it=events.begin();
            e_it!=events.end();
            e_it++)
        {

            if((*e_it)->is_thread_join())
            {
                join_flag = true;
                if (equation.array_thread_id)
                    unhandled.push_back(++thr_n);
                else {
                    int thr = equation.thread_id_map[(*e_it)->pthread_join_id];
                    unhandled.push_back(thr);
                }

                continue;
            }

            if((*e_it)->is_memory_barrier())
                continue;
            if ((*e_it)->is_verify_atomic_begin(equation.mutex_flag)) {
                if (valid_mutex(equation)) {
                    atomic_flag = true;
                    if ((*e_it)->is_verify_lock(equation.mutex_flag)) {
                        event_value_map.clear();
                        lock_flag = true;
                    }
                }
                continue;
            }
            if ((*e_it)->is_verify_atomic_end(equation.mutex_flag)) {
                atomic_flag = false;
                start_flag = false;
                if ((*e_it)->is_verify_unlock(equation.mutex_flag)) {
                    event_value_map.clear();
                    lock_flag = false;
                }
                continue;
            }

            if (join_flag && (equation.thread_malloc || !equation.aux_enable || !(*e_it)->is_aux_var()))
            {
                join_flag = false;
                for (unsigned i = 0; i < unhandled.size(); i++) {
                    join_nodes[unhandled[i]] = (*e_it);
                }
                unhandled.clear();
            }

            if (lock_flag) {
                irep_idt address = (*e_it)->original_lhs_object.get_identifier();
                if ((*e_it)->is_shared_read()) {
                    if (event_value_map.find(address) == event_value_map.end()) {
                        event_value_map[address] = *e_it;
                    }
                    else {
                        continue;
                    }
                }
                else if ((*e_it)->is_shared_write()) {
                    event_value_map[address] = *e_it;
                }
            }

            if(previous==equation.SSA_steps.end())
            {
                // first one?
                previous=*e_it;

                if (atomic_flag && !start_flag)
                    start_flag = true;

                continue;
            }

            if (previous->array_assign)
            {
                array_assign = true;
                array_event = previous;
            }

            if(previous->is_shared_read() && previous->struct_assign)
            {
                struct_assign = true;
                struct_event = previous;
            }

            if((start_flag) || (previous->atomic_section_id!=0 && previous->atomic_section_id == (*e_it)->atomic_section_id) ||
               array_assign || struct_assign)
            {
                o_edge new_edge(&(*previous), &(*(*e_it)), edge::EPO, tmpc);
                eog.m_pos.push_back(new_edge);
            }
            else {
                o_edge new_edge(&(*previous), &(*(*e_it)), edge::PO, tmpc);
                eog.m_pos.push_back(new_edge);
            }

            if (array_assign && array_event->original_lhs_object.get_identifier() == (*e_it)->original_lhs_object.get_identifier())
            {
                array_assign = false;
            }

            if (struct_assign && struct_event->original_lhs_object.get_identifier() == (*e_it)->original_lhs_object.get_identifier())
            {
                struct_assign = false;
            }

            if (atomic_flag && !start_flag)
                start_flag = true;

            previous=*e_it;
        }
    }

    if (!join_nodes.empty()) {
        for(per_thread_mapt::const_iterator
                    t_it=per_thread_map.begin();
            t_it!=per_thread_map.end();
            t_it++)
        {
            const event_listt &events=t_it->second;
            if (!events.empty()) {
                event_listt::const_reverse_iterator e_it = events.rbegin();
                for (; e_it != events.rend(); e_it++)
                {
                    if (((*e_it)->is_shared_read() || (*e_it)->is_shared_write())
                        && (equation.thread_malloc || !equation.aux_enable || !(*e_it)->is_aux_var()))
                    {
                        break;
                    }
                }

                if (e_it != events.rend() && join_nodes.find((*e_it)->source.thread_nr) != join_nodes.end()) {
                    o_edge new_edge(&(*(*e_it)), &(*join_nodes[(*e_it)->source.thread_nr]), edge::PO, tmpc);
                    eog.m_pos.push_back(new_edge);
                }
            }
        }
    }
}

void bmct::thread_spawn(
        symex_target_equationt &equation,
        const per_thread_mapt &per_thread_map,
        prop_convt &prop_conv,
        EOG& graph, bool trace_flag)
{
    // thread spawn: the spawn precedes the first
    // instruction of the new thread in program order
    exprt tmpc; tmpc.make_false();
    unsigned next_thread_id=0;
    for(eventst::const_iterator
                e_it=equation.SSA_steps.begin();
        e_it!=equation.SSA_steps.end();
        e_it++)
    {
        if(e_it->is_spawn())
        {
            per_thread_mapt::const_iterator next_thread=
                    per_thread_map.find(++next_thread_id);
            if(next_thread==per_thread_map.end() ||
               (trace_flag && prop_conv.l_get((*e_it).guard_literal)!=tvt(true)))
                continue;

            event_listt::const_iterator n_it=next_thread->second.begin();

            for( ;n_it!=next_thread->second.end() &&
                  !(*n_it)->is_shared_read() &&
                  !(*n_it)->is_shared_write();
                  ++n_it)
                ;

            if (n_it!=next_thread->second.end()) {
                o_edge new_edge(&(*e_it), &(*(*n_it)), edge::PO, tmpc);
                graph.m_pos.push_back(new_edge);
            }
        }
    }
}

void bmct::read_from_extraction(EOG& eog, prop_convt &prop_conv)
{
    typedef symex_target_equationt::choice_symbol_mapt cs_mapt;
    for(cs_mapt::const_iterator
                t_it=equation.choice_symbol_map.begin();
        t_it!=equation.choice_symbol_map.end();
        t_it++)
    {
        symbol_exprt choice = t_it->first;
        symex_target_equationt::eq_edge* eqe = t_it->second;
        if (prop_conv.get(choice).is_true())
        {
            if (!equation.thread_malloc && equation.aux_enable && (eqe->m_src)->is_aux_var())
                continue;

            if (prop_conv.l_get(eqe->m_src->guard_literal)!=tvt(true) ||
                prop_conv.l_get(eqe->m_dst->guard_literal)!=tvt(true))
            {
                continue;
            }

            o_edge new_edge(eqe->m_src, eqe->m_dst, edge::RF, choice);
            eog.m_rfs.push_back(new_edge);
        }
    }
}

// -------------------------------------------------------------
// Functions for CE_evaluation_graph
// -------------------------------------------------------------
void bmct::add_all_nodes(DEOG& graph)
{
    int id = 0;
    for(eventst::iterator
                e_it=equation.SSA_steps.begin();
        e_it!=equation.SSA_steps.end();
        e_it++)
    {
        if ((e_it->is_shared_read() || e_it->is_shared_write() ||
             e_it->is_spawn() || e_it->is_memory_barrier())) {
            graph.add_all_node(&(*e_it));
            e_it->id = id++;
        }
    }
    graph.init_pa_sons();
}

void bmct::deog_generation(DEOG& deog, EOG& eog, bool with_rf)
{
    // clear
    deog.clear();

    // add nodes
    for(size_t i = 0; i < eog.m_nodes.size(); i++)
        deog.add_node(eog.m_nodes[i]);
    deog.initial_addr_nodes_map();

    // add po edges
    for (size_t i = 0; i < eog.m_pos.size(); i++) {
        o_edge e = eog.m_pos[i];
        deog.add_edge(&(*e.m_src), &(*e.m_dst), e.m_type, e.m_reason);
    }
    deog.update_po_sons();

    // add rf edges
    if (with_rf) {
        for (size_t i = 0; i < eog.m_rfs.size(); i++) {
            o_edge e = eog.m_rfs[i];
            deog.add_edge(&(*e.m_src), &(*e.m_dst), e.m_type, e.m_reason);
        }
    }
}

bool bmct::valid_mutex(symex_target_equationt &equation)
{
    int mutex_num = 0;
    for(eventst::const_iterator
                e_it=equation.SSA_steps.begin();
        e_it!=equation.SSA_steps.end();
        e_it++)
    {
        // concurreny-related?
        if(e_it->is_verify_atomic_begin(equation.mutex_flag))
            mutex_num++;
    }
    return (mutex_num != 1);
}

// -------------------------------------------------------------
// Functions for CE_evaluation_constraint
// -------------------------------------------------------------
void bmct::encode_program_order(EOG& eog, exprt& constraint, std::map<event_it, EPO>& epo_map)
{
    std::map<const eventt*, event_it> event_map;
    for(eventst::const_iterator e_it=equation.SSA_steps.begin();
        e_it!=equation.SSA_steps.end();
        e_it++)
    {
        if(!e_it->is_shared_read() &&
           !e_it->is_shared_write() &&
           !e_it->is_spawn() &&
           !e_it->is_memory_barrier()&&
           !e_it->is_verify_atomic_begin(equation.mutex_flag) &&
           !e_it->is_verify_atomic_end(equation.mutex_flag) &&
           !e_it->is_thread_join()) continue;

        event_map[&(*e_it)] = e_it;
    }

    int current_thread_id = -1;
    EPO epo;
    for (size_t i = 0; i < eog.m_pos.size(); i++) {
        o_edge& e_po = eog.m_pos[i];
        event_it src = event_map[e_po.m_src];
        event_it dst = event_map[e_po.m_dst];

        constraint = and_exprt(constraint, memory_model->before(src, dst));

        if (e_po.m_type == edge::EPO) {
            if(src->source.thread_nr == current_thread_id) {
                epo.end = dst;
                epo.atomic_events.push_back(dst);
            }
            else
            {
                for (unsigned i = 0; i < epo.atomic_events.size(); i++)
                    epo_map[epo.atomic_events[i]] = epo;

                epo.atomic_events.clear();
                epo.atomic_events.push_back(src);
                epo.atomic_events.push_back(dst);
                epo.begin = src;
                epo.end = dst;

                current_thread_id = dst->source.thread_nr;
            }
        }
        else {
            assert(e_po.m_type == edge::PO);

            for (unsigned i = 0; i < epo.atomic_events.size(); i++)
                epo_map[epo.atomic_events[i]] = epo;

            epo.begin = epo.end = dst;
            epo.atomic_events.clear();
            epo.atomic_events.push_back(dst);

            if(dst->source.thread_nr != current_thread_id)
                current_thread_id = dst->source.thread_nr;
        }
    }
}

void bmct::encode_read_from(EOG& eog, prop_convt &solver, bvt& assumptions,
                            std::map<literalt, symbol_exprt>& lit_choice_map,
                            std::map<event_it, EPO>& epo_map)
{
    // compute event_map and address_map
    std::map<irep_idt, event_listt> address_map;
    std::map<const eventt*, event_it> event_map;
    for(eventst::const_iterator
                e_it=equation.SSA_steps.begin();
        e_it!=equation.SSA_steps.end();
        e_it++)
    {
        // concurreny-related?
        if(!e_it->is_shared_read() &&
           !e_it->is_shared_write() &&
           !e_it->is_spawn() &&
           !e_it->is_memory_barrier()&&
           !e_it->is_verify_atomic_begin(equation.mutex_flag) &&
           !e_it->is_verify_atomic_end(equation.mutex_flag) &&
           !e_it->is_thread_join()) continue;

        event_map[&(*e_it)] = e_it;

        if (e_it->is_shared_write())
            address_map[e_it->original_lhs_object.get_identifier()].push_back(e_it);
    }

    // compute rf_choice_map
    std::map<irep_idt, symbol_exprt> rf_choice_map;
    typedef symex_target_equationt::choice_symbol_mapt cs_mapt;
    for(cs_mapt::const_iterator
                t_it=equation.choice_symbol_map.begin();
        t_it!=equation.choice_symbol_map.end();
        t_it++)
    {
        symbol_exprt choice = t_it->first;
        symex_target_equationt::eq_edge* eqe = t_it->second;
        rf_choice_map[eqe->m_src->ssa_lhs.get_identifier() + eqe->m_dst->ssa_lhs.get_identifier()] = choice;
    }

    for (size_t i = 0; i < eog.m_rfs.size(); i++) {
        o_edge e_po = eog.m_rfs[i];
        event_it src = event_map[e_po.m_src];
        event_it dst = event_map[e_po.m_dst];

        exprt prec = before(src, dst, epo_map);
        exprt forbidden = true_exprt();
        event_listt& writes = address_map[src->original_lhs_object.get_identifier()];
        for (event_listt::iterator e_it = writes.begin(); e_it != writes.end(); e_it++)
            if ((*e_it)->ssa_lhs.get_identifier() != src->ssa_lhs.get_identifier())
                forbidden = and_exprt(forbidden, or_exprt(before(*e_it, src, epo_map), before(dst, *e_it, epo_map)));

        literalt c = solver.convert(and_exprt(prec, forbidden));
        assumptions.push_back(c);
        lit_choice_map[c] = rf_choice_map[src->ssa_lhs.get_identifier() + dst->ssa_lhs.get_identifier()];
    }
}

exprt bmct::before(event_it e1, event_it e2, std::map<event_it, EPO>& epo_map)
{
    if (epo_map.find(e1) != epo_map.end() && epo_map.find(e2) != epo_map.end()) {
        unsigned i;
        for (i = 0; i < epo_map[e1].atomic_events.size(); i++) {
            if (epo_map[e1].atomic_events[i]->ssa_lhs.get_identifier() == e2->ssa_lhs.get_identifier())
                break;
        }
        if (i == epo_map[e1].atomic_events.size()) {
            return memory_model->before(epo_map[e1].end, epo_map[e2].begin);
        }
        else
            return memory_model->before(e1, e2);
    }
    return memory_model->before(e1, e2);
}


//===================================================================
// Functions for initial refinement computation
//===================================================================
void bmct::compute_init_refinement(prop_convt &prop_conv, exprt& refinement)
{
#if output_reason
    std::cout<<"===================Compute Init Refinement Begin========================\n";
#endif
    DEOG deog(&equation);

    add_all_nodes(deog);

    EOG eog;
    EOG_extraction(prop_conv, eog, false);
    deog_generation(deog, eog, false);

    exprt::operandst operands;

    // compute single-rf refinement
    single_rf_refinement_generation(deog, operands);

    // compute two-rf refinement
    two_rf_refinement_generation(deog, operands);

    // construct the constraint
    refinement = conjunction(operands);
#if output_reason
    std::cout << "Init Constraints: " << "\n";
    std::cout << from_expr(ns, "", refinement) << "\n";
    std::cout<<"===================Compute Init Refinement End========================\n";
#endif

    deog.clear();
}

void bmct::single_rf_refinement_generation(DEOG& graph, exprt::operandst& constraint_operands)
{
    address_mapt address_map;
    compute_address_map(address_map);

    int num = 0;

    for (cs_mapt::const_iterator i_it = equation.choice_symbol_map.begin();
         i_it != equation.choice_symbol_map.end(); i_it++)
    {
        symex_target_equationt::eq_edge* rf = i_it->second;
        node* n_src = graph.event_node_map[rf->m_src];
        node* n_dst = graph.event_node_map[rf->m_dst];

        if (!graph.is_son_of(n_src, n_dst))
            continue;

        std::vector < exprt::operandst > reasons;

        const irep_idt var = rf->m_src->original_lhs_object.get_identifier();
        std::vector < event_it > &writes = address_map[var].writes;

        for (event_listt::iterator w_it = writes.begin(); w_it != writes.end(); w_it++)
        {
            node* w = graph.event_node_map[&(*(*w_it))];
            if (w != n_src && graph.is_son_of(n_src, w) && graph.is_son_of(w, n_dst))
            {
                // add constraint !choice || !w->guard
                exprt::operandst operands;
                operands.push_back(not_exprt(i_it->first));
                exprt& guard = w->m_event->guard;
                if (!guard.is_true())
                {
                    if (guard.has_operands() && guard.id() == ID_and)
                    {
                        for (unsigned i = 0; i < guard.operands().size(); i++)
                            operands.push_back( not_exprt(guard.operands()[i]));
                    }
                    else
                    {
                        operands.push_back(not_exprt(guard));
                    }
                }
                reasons.push_back(operands);
            }
        }

        // remove redundant reasons
        std::vector < exprt::operandst > effective_reasons;
        redundant_reason_remove(reasons, effective_reasons);

        // add those effective ones to constraint_operands
        for (unsigned i = 0; i < effective_reasons.size(); i++) {
            exprt reason_exprt = disjunction(effective_reasons[i]);
            constraint_operands.push_back(reason_exprt);
            num++;
        }
    }
//	std::cout << "Single RF constraint size: " << num << "\/" << equation.choice_symbol_map.size() << "\n";
}

bool check_guard(const eventt* e)
{
    std::string str = e->source.pc->source_location.get_file().c_str();
    return str.find("sync") != std::string::npos;
}

void bmct::two_rf_refinement_generation(DEOG& graph, exprt::operandst& constraint_operands)
{
    std::map<const eventt*, eventt*> before_write_map;
    compute_before_write(before_write_map);

    std::map<const eventt*, eventt*> EPO_write_map;
    compute_EPO_write(graph, EPO_write_map);

    // compute address_map
    address_mapt address_map;
    compute_address_map(address_map);
    int num = 0;
    for (cs_mapt::const_iterator i_it = equation.choice_symbol_map.begin();
         i_it != equation.choice_symbol_map.end(); i_it++)
    {
        cs_mapt::const_iterator j_it = i_it;
        j_it++;

        for (; j_it != equation.choice_symbol_map.end(); j_it++)
        {
            symex_target_equationt::eq_edge* rf1 = i_it->second;
            symex_target_equationt::eq_edge* rf2 = j_it->second;

            if (rf1->m_src != rf2->m_src && rf1->m_dst != rf2->m_dst)
            {
                if ((graph.is_son_of(graph.event_node_map[rf1->m_dst], graph.event_node_map[rf2->m_src]) &&
                     graph.is_son_of(graph.event_node_map[rf2->m_dst], graph.event_node_map[rf1->m_src])) ||
                    (rf1->m_src->original_lhs_object == rf2->m_src->original_lhs_object &&
                     graph.is_son_of(graph.event_node_map[rf2->m_src], graph.event_node_map[rf1->m_src]) &&
                     graph.is_son_of(graph.event_node_map[rf1->m_dst], graph.event_node_map[rf2->m_dst])) ||
                    (rf1->m_src->original_lhs_object == rf2->m_src->original_lhs_object &&
                     graph.is_son_of(graph.event_node_map[rf1->m_src], graph.event_node_map[rf2->m_src]) &&
                     graph.is_son_of(graph.event_node_map[rf2->m_dst], graph.event_node_map[rf1->m_dst])))
                {
                    num++;
                    if (num > max_two_rf_num)
                        break;

                    exprt::operandst operands;
                    operands.push_back(not_exprt(i_it->first));
                    operands.push_back(not_exprt(j_it->first));
                    exprt reason_exprt = disjunction(operands);
                    constraint_operands.push_back(reason_exprt);
                }
            }

            if(rf1->m_src == rf2->m_src)
            {
                const eventt* w1 = compute_mid_write(address_map, graph, rf1->m_dst, rf2->m_dst);
                if (graph.is_son_of(graph.event_node_map[rf1->m_dst], graph.event_node_map[rf2->m_dst]) && w1 != NULL
                        )
                {
                    num++;
                    if (num > max_two_rf_num)
                        break;

                    exprt::operandst operands;
                    operands.push_back(not_exprt(i_it->first));
                    operands.push_back(not_exprt(j_it->first));
                    operands.push_back(not_exprt(w1->guard));
                    exprt reason_exprt = disjunction(operands);
                    constraint_operands.push_back(reason_exprt);
                }

                const eventt* w2 = compute_mid_write(address_map, graph, rf2->m_dst, rf1->m_dst);
                if (graph.is_son_of(graph.event_node_map[rf2->m_dst], graph.event_node_map[rf1->m_dst]) && w2 != NULL
                        )
                {
                    num++;
                    if (num > max_two_rf_num)
                        break;

                    exprt::operandst operands;
                    operands.push_back(not_exprt(i_it->first));
                    operands.push_back(not_exprt(j_it->first));
                    operands.push_back(not_exprt(w2->guard));
                    exprt reason_exprt = disjunction(operands);
                    constraint_operands.push_back(reason_exprt);
                }
            }

            if(rf1->m_src == rf2->m_src &&
               EPO_write_map.find(rf1->m_dst) != EPO_write_map.end() &&
               EPO_write_map.find(rf2->m_dst) != EPO_write_map.end())
            {
                num++;
                if (num > max_two_rf_num)
                    break;

                exprt::operandst operands;
                operands.push_back(not_exprt(i_it->first));
                operands.push_back(not_exprt(j_it->first));
//                operands.push_back(not_exprt(EPO_write_map[rf1->m_dst]->guard));
//                operands.push_back(not_exprt(EPO_write_map[rf2->m_dst]->guard));

                if(!check_guard(rf1->m_dst))
                {
                    operands.push_back(not_exprt(EPO_write_map[rf1->m_dst]->guard));
                    operands.push_back(not_exprt(EPO_write_map[rf2->m_dst]->guard));
                }
                exprt reason_exprt = disjunction(operands);
                constraint_operands.push_back(reason_exprt);
            }
        }

        if (num > max_two_rf_num)
            break;
    }
//	std::cout << "Two RF constraint size: " << num << "\n";
}

bool exprt_vec_compare(const exprtvt& r1, const exprtvt& r2) {
    return r1.size() < r2.size();
}

bool exprt_compare(const exprt& r1, const exprt& r2) {
    return r1 < r2;
}

bool exprt_subset(const exprt::operandst& r1, const exprt::operandst& r2) {
    unsigned i = 0, j = 0;
    for (i = 0; i < r1.size(); i++) {
        for (; j < r2.size(); j++) {
            if (r2[j] == r1[i]) {
                break;
            }
        }
        if (j == r2.size())
            return false;
        else
            j++;
    }
    return true;
}

void bmct::redundant_reason_remove( std::vector<exprt::operandst>& reasons,
                                    std::vector < exprt::operandst >& effective_reasons)
{
    for (unsigned i = 0; i < reasons.size(); i++) {
        sort(reasons[i].begin(), reasons[i].end(), exprt_compare);
    }
    sort(reasons.begin(), reasons.end(), exprt_vec_compare);
    ;
    for (unsigned i = 0; i < reasons.size(); i++) {
        unsigned j;
        for (j = 0; j < effective_reasons.size(); j++) {
            if (exprt_subset(effective_reasons[j], reasons[i]))
                break;
        }
        if (j == effective_reasons.size()) {
            effective_reasons.push_back(reasons[i]);
        }
    }
}

const eventt* bmct::compute_mid_write(address_mapt& address_map, DEOG& graph, const eventt* dst1, const eventt* dst2)
{
    event_listt& writes = address_map[dst1->original_lhs_object.get_identifier()].writes;
    for (size_t i = 0; i < writes.size(); i++)
    {
        if (graph.is_son_of(graph.event_node_map[dst1], graph.event_node_map[&(*writes[i])]) &&
            graph.is_son_of(graph.event_node_map[&(*writes[i])], graph.event_node_map[dst2]))
            return &(*writes[i]);
    }
    return NULL;
}

void bmct::compute_EPO_write(DEOG& graph, std::map<const eventt*, eventt*>& EPO_write_map)
{
    for (int i = 0; i < graph.m_vnodes.size(); i++) {
        node* n = graph.m_vnodes[i];
        if (n->is_r()) {
            for (edgest::iterator jt = n->m_output_epos.begin(); jt != n->m_output_epos.end(); jt++) {
                node* dst = (*jt)->m_dst;
                if (dst->is_w() && dst->address() == n->address()) {
//                    std::cout << "aaaa: " << n->m_event->ssa_lhs.get_identifier() << " : " <<dst->m_event->ssa_lhs.get_identifier() << "\n";
                    EPO_write_map[n->m_event] = dst->m_event;
                    break;
                }
            }
        }
    }
}

void bmct::compute_before_write(std::map<const eventt*, eventt*>& before_write_map) {
    std::map<int, std::map<irep_idt, eventt*> > var_thread_map;
    for (eventst::iterator e_it = equation.SSA_steps.begin();
         e_it != equation.SSA_steps.end(); e_it++) {
        if (e_it->is_shared_read()) {
            int thread_id = e_it->source.thread_nr;
            irep_idt var = e_it->original_lhs_object.get_identifier();
            if (var_thread_map.find(thread_id) != var_thread_map.end()
                && var_thread_map[thread_id].find(var)
                   != var_thread_map[thread_id].end()) {
                before_write_map[&(*e_it)] = var_thread_map[thread_id][var];
            } else {
                before_write_map[&(*e_it)] = NULL;
            }
        } else if (e_it->is_shared_write()) {
            int thread_id = e_it->source.thread_nr;
            const irep_idt var = e_it->original_lhs_object.get_identifier();
            if (var_thread_map.find(thread_id) != var_thread_map.end()) {
                var_thread_map[thread_id][var] = &(*e_it);
            } else {
                std::map<irep_idt, eventt*> tmp;
                tmp[var] = &(*e_it);
                var_thread_map[thread_id] = tmp;
            }
        }
    }
}

void bmct::compute_address_map(address_mapt& address_map) {
    for (eventst::iterator
                 e_it = equation.SSA_steps.begin();
         e_it != equation.SSA_steps.end();
         e_it++)
    {
        if (e_it->is_shared_read()) {
            address_map[e_it->original_lhs_object.get_identifier()].reads.push_back(e_it);
        } else if (e_it->is_shared_write()) {
            address_map[e_it->original_lhs_object.get_identifier()].writes.push_back(e_it);
        }
    }
}

